# 动态规划

也是将问题分为若干子问题，与分治法不同的是动规的子问题不互相独立。
动规将已解决的答案保留下来，避免重复计算。（使用递归时，如斐波那契数列中的重复）
上楼梯的解决思想是从结束点分解子问题，然后记录子问题的结果。

## 最大连续子序列之和
问题：A[i] 为末尾的最长子序列 dp[i]
求解：dp[i] = max {A[i] ,dp[i-1] + A[i]}
子问题：dp[i-1]

## 最长递增子序列
问题： A[i] 为末尾节点的最长递增子序列 dp[i]
求解： dp[i] = max {1, dp[j]+1 || j<i } (遍历找出最大的) 
子问题： dp[j]

## 最长公共子序列
问题：给定两个字符串S1和S2，求一个最长公共子串长度。
子问题：字符串S1第i个字符结尾，和字符串S2第j个字符串结尾的最长公共子串长度。归纳法：左上角的矩阵已经解出。
求解：S1第i个字符和S2第j个字符相等，不相等。
相等时 dp[i][j] = dp[i-1][j-1] + 1
不等时 (S1或S2的末尾字符无用)dp[i][j] = max {dp[i][j-1], dp[i-1][j]}

## 背包问题
0-1 背包
问题描述：n件物品，每件物品重量为w[i], 价值为v[i]，现在有容量为m的背包，选择物品使得装入背包物品的价值最大。
求解：dp[i][j] 为有第i件及i以前的物品，背包容量为j的子问题的解。归纳法：左上角矩形全部被求解。
    (要么第i件物品放入，dp[i-1][j-w[i]] + v[i]；要么第i件物品没放入dp[i-1][j]) dp[i][j] = max{dp[i-1][j-w[i]] + v[i], dp[i-1][j]}
二维数组到一维数组的优化：发现只与本行的上一行有关。而我们要求的只是最后一行。倒序遍历可以保证dp[i-1][j-w[i]]未被修改。
    dp[j] = max{dp[j], dp[j-w[i]] + v[i]}

完全背包
0-1背包扩展，每种物品不只可以取一件而且可以取多件。
相比于0-1背包，只是多了考虑放几件的问题而已。
求解：dp[i][j]。归纳：左上角的矩形全部被求解。
    (第i件物品放入0，1，...件) dp[i][j] = max {dp[i-1][j] + 0*v[i], ... , dp[i-1][j - k*w[i]] + k*v[i], ...}
更简单的一种求解：
    转移方程
    0-1 ：dp[i-1][j-w[i]] + v[i] 完全背包：dp[i][j-w[i]] + v[i]
    同理有二维数组到一位数组的优化。要保证dp[i][j-w[i]]已更新，因此要正序遍历。
    dp[j] = max {dp[j], dp[j-w[i]]}

多重背包
法零：法一更有技巧的拆分将物品按二进制合并成若干组，使ki -> log(ki)
法一：视为重量价值相同的不同物品使用0-1背包m*sigmod(ki)。
法二：每种商品最多只能取ki件时间复杂度为m*sigmod(ki)。
同样可以使用二维到一维的简化。需要倒序遍历。

## 划分数问题
https://blog.csdn.net/csyifanZhang/article/details/105652758


